local grav = 28

local function BallPosAtTime(initial_position, initial_velocity, gravity, t)
    local predicted_position = initial_position + initial_velocity * t + 0.5 * Vector3.new(0, -gravity, 0) * t ^ 2
    return predicted_position
end

local function createPartsAndBeam(x0, v0, airtime, visible)
    local parts = {}
    local attachments = {}
    local transparency = visible and 0.6 or 1
    local lastAttachment = nil

    for t = 0, airtime, 0.05 do
        local POS = BallPosAtTime(x0, v0, grav, t)
        local Part = Instance.new("Part")
        Part.Parent = workspace
        Part.Size = Vector3.new(3, 2, 3)
        Part.Anchored = true
        Part.Color = Color3.fromRGB(0, 147, 204) -- Blue color
        Part.CanCollide = false
        Part.Rotation = Vector3.new(-90, 0, 90)
        Part.Position = POS
        Part.Transparency = 1        table.insert(parts, Part)

        local attachment = Instance.new("Attachment", Part)
        table.insert(attachments, attachment)

        if lastAttachment then
            local beam = Instance.new("Beam")
            beam.Parent = Part
            beam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- Purple color
            beam.Texture = "rbxassetid://18231379988"
            beam.Attachment0 = lastAttachment
            beam.Attachment1 = attachment
            beam.Width0 = 1.5
            beam.Width1 = 1.5
        end

        lastAttachment = attachment
    end
    return parts
end

workspace.ChildAdded:Connect(function(c)
    game:GetService("RunService").Stepped:Wait()
    if c.Name ~= "Football" or c:IsA("Tool") then return end

    local x0 = c.Position
    local v0 = c.Velocity

    local airtime = (-v0.Y - math.sqrt(v0.Y ^ 2 - 4 * 0.5 * -grav * x0.Y)) / (2 * 0.5 * -grav)

    local parts = createPartsAndBeam(x0, v0, airtime, true)

    task.wait(airtime + 1.75)

    for _, Part in ipairs(parts) do
        Part:Destroy()
    end
end)
